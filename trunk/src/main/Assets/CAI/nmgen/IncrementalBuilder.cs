/*
 * Copyright (c) 2011 Stephen A. Pratt
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
using System;
using System.Collections.Generic;
using org.critterai.geom;
#if NUNITY
using Vector3 = org.critterai.Vector3;
#else
using Vector3 = UnityEngine.Vector3;
#endif

namespace org.critterai.nmgen
{
    /// <summary>
    /// 
    /// </summary>
    /// <remarks>
    /// <para>The <see cref="IncrementalBuilder"/> does not currently support
    /// compact heightfield post-processors.  It will ignore any 
    /// <see cref="ICHFProcessor"/> that is marked as a post processor.
    /// (Compact heightfield post processors will be supported once
    /// the compact heightfield is fully editable.)</para>
    /// </remarks>
    public sealed class IncrementalBuilder
    {
        public const int MinAllowedTileSize = 12;
        private const string pre = "NMGen Build: ";
        private const string pret = pre + "Trace: ";

        private NMGenTileParams mTileConfig;
        private NMGenParams mConfig;
        private BuildFlags mFlags;
        private BuildState mState = BuildState.Initialized;
        private readonly BuildContext context;

        private bool mTrace;
        private bool mNoResult;

        private NMGenInputGeom mSource;
        private ProcessorSet mProcessors;

        private Object mPrimary;
        private Object mSecondary;

        public bool TraceEnabled { get { return mTrace; } }

        /// <summary>
        /// The current state of the builder.
        /// </summary>
        /// <remarks>
        /// If the value is an unfinished state, then it represents the 
        /// build step that will occur the next time the <see cref="Build"/> 
        /// method called.
        /// </remarks>
        public BuildState State { get { return mState; } }
        public bool NoResult { get { return mNoResult; } }

        /// <summary>
        /// TRUE if the the build has finished.  (Successfully or not.)
        /// </summary>
        public bool IsFinished
        {
            get
            {
                return (mState == BuildState.Aborted
                    || mState == BuildState.Complete);
            }
        }

        public int TileX { get { return mTileConfig.X; } }
        public int TileZ { get { return mTileConfig.Z; } }

        /// <summary>
        /// The <see cref="PolyMesh"/> created by the build, or NULL if no
        /// mesh is available.
        /// </summary>
        public PolyMesh PolyMesh
        {
            get
            {
                if (mState == BuildState.Complete && !NoResult)
                    return (PolyMesh)mPrimary;
                return null;
            }
        }

        /// <summary>
        /// The <see cref="PolyMeshDetail"/> created by the build, or NULL
        /// if no mesh is available.
        /// </summary>
        public PolyMeshDetail DetailMesh
        {
            get
            {
                if (mState == BuildState.Complete && !NoResult)
                    return (PolyMeshDetail)mSecondary;
                return null;
            }
        }

        /// <summary>
        /// The number of messages generated by the build.
        /// </summary>
        public int MessageCount 
        { 
            get 
            {
                if (mTrace
                    || mState == BuildState.Aborted
                    || context.MessageCount == 1)   // For initialization failures.
                {
                    return context.MessageCount;
                }
                else
                    return 0;
            } 
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <remarks>
        /// <para>WARNING: Don't forget to set the easily overlooked tile size
        /// and bounds properties in the <paramref name="config"/>
        /// object!  These properties don't have any valid default values 
        /// and using the configuration without setting them will result in 
        /// empty meshes.
        /// </para>
        /// <para>The <typeparamref name="areas"/> parameter is optional.
        /// If provided, it is expected to contain the area ids associated
        /// with each triangle in the source.  The build process will only clear
        /// the walkable area for triangles determined to be unwalkable.</para>
        /// <para>If <typeparamref name="areas"/> is null, all walkable
        /// triangles will be assigned an area id of 
        /// <see cref="NMGen.WalkableArea"/>.</para>
        /// </remarks>
        /// <param name="trace">TRUE if detailed trace messages should be
        /// recored during the build process.</param>
        /// <param name="config">The build configuration.</param>
        /// <param name="buildFlags">Flags indicating which optional build
        /// steps to include.</param>
        /// <param name="source">The source geometry.</param>
        /// <param name="areas">Area ids to apply to the source triangles.
        /// [Size: >= triangle count] [Optional]</param>
        private IncrementalBuilder(NMGenTileParams tileConfig
            , NMGenParams config
            , BuildFlags buildFlags
            , NMGenInputGeom source
            , ProcessorSet processors
            , bool trace)
        {
            // Note: Context logging is always on for error reporting.
            context = new BuildContext(true);

            mTrace = trace;

            mConfig = config;
            mTileConfig = tileConfig;

            mSource = source;
            mProcessors = processors;
            mFlags = buildFlags;

            mPrimary = source;
            mState = BuildState.Initialized;
        }

        private IncrementalBuilder()
        {
            context = new BuildContext(true);
            context.Log("Nothing to build. (Usually means no geometry in tile bounds.)");
            mNoResult = true;
            mState = BuildState.Complete;
        }

        /// <summary>
        /// Gets available build messages, or a zero length array if no messages
        /// are available.
        /// </summary>
        /// <returns>Available build messages.</returns>
        public string[] GetMessages() 
        {
            if (mTrace
                || mState == BuildState.Aborted
                || context.MessageCount == 1)   // For initialization failures.
                return context.GetMessages();
            else
                return new string[0]; 
        }

        /// <summary>
        /// Performs a single build step.
        /// </summary>
        /// <remarks><para>The result state will represent either a finished state
        /// or the build step that will be performed during the next call to
        /// the method.</para></remarks>
        /// <returns>The state at the end of the build step.</returns>
        public BuildState Build()
        {
            switch (mState)
            {
                case BuildState.Initialized:
                    mState = BuildState.ClearUnwalkableTris;
                    break;
                case BuildState.ClearUnwalkableTris:
                    ClearUnwalkableTris();
                    break;
                case BuildState.HeightfieldBuild:
                    BuildHeightfield();
                    break;
                case BuildState.MarkHeightfieldSpans:
                    MarkHeightfieldSpans();
                    break;
                case BuildState.HeightfieldPostProcess:
                    PostProcessHeightfield();
                    break;
                case BuildState.CompactFieldBuild:
                    BuildCompactField();
                    break;
                case BuildState.CompactFieldMidProcess:
                    MidProcessCompactField();
                    break;
                case BuildState.ErodeWalkableArea:
                    ErodeWalkableArea();
                    break;
                case BuildState.DistanceFieldBuild:
                    BuildDistanceField();
                    break;
                case BuildState.RegionBuild:
                    BuildRegions();
                    break;
                case BuildState.ContourBuild:
                    BuildContours();
                    break;
                case BuildState.PolyMeshBuild:
                    BuildPolyMesh();
                    break;
                case BuildState.PolyMeshPostProcess:
                    PostProcessPolyMesh();
                    break;
                case BuildState.DetailMeshBuild:
                    BuildDetailMesh();
                    break;
                case BuildState.DetailMeshPostProcess:
                    PostProcessDetailMesh();
                    break;
            }
            return mState;
        }

        private void ClearUnwalkableTris()
        {
            TriangleMesh mesh =  new TriangleMesh(
                mSource.UnsafeVerts, mSource.UnsafeVerts.Length
                , mSource.UnsafeTris, mSource.UnsafeTris.Length / 3);

            // The clone is needed since the content of the array will be altered.
            byte[] areas = (byte[])mSource.UnsafeAreas.Clone();

            NMGen.ClearUnwalkableTriangles(context
                , mesh
                , mConfig.walkableSlope
                , areas);
            if (mTrace)
                context.Log(pret + "Cleared unwalkable triangles");

            mPrimary = mesh;
            mSecondary = areas;
            mState = BuildState.HeightfieldBuild;
        }

        private void BuildHeightfield()
        {
            int width;
            int depth;

            NMGen.DeriveSizeOfCellGrid(mTileConfig.BoundsMin
                , mTileConfig.BoundsMax
                , mConfig.XZCellSize
                , out width
                , out depth);

            Heightfield hf = new Heightfield(width
                , depth
                , mTileConfig.boundsMin
                , mTileConfig.boundsMax
                , mConfig.xzCellSize
                , mConfig.yCellSize);

            hf.AddTriangles(context
                , (TriangleMesh)mPrimary
                , (byte[])mSecondary
                , mConfig.walkableStep);  // Merge for any spans less than step.
            
            if (mTrace)
                context.Log(pret + "Voxelized triangles. Span count: " 
                    + hf.GetSpanCount());

            if (hf.GetSpanCount() < 1)
            {
                context.Log("Complete at heightfield build."
                    + " Heightfield does not have any spans.");
                mState = BuildState.Complete;
                mNoResult = true;
                return;
            }

            mPrimary = hf;
            mSecondary = null;

            if ((mFlags
                & (BuildFlags.LowObstaclesWalkable
                    | BuildFlags.LedgeSpansNotWalkable
                    | BuildFlags.LowHeightSpansNotWalkable)) != 0)
            {
                mState = BuildState.MarkHeightfieldSpans;
            }
            else
                mState = BuildState.CompactFieldBuild;
        }

        private void MarkHeightfieldSpans()
        {
            Heightfield hf = (Heightfield)mPrimary;

            if ((mFlags & BuildFlags.LowObstaclesWalkable) != 0
                && mConfig.walkableStep > 0)
            {
                hf.MarkLowObstaclesWalkable(context, mConfig.walkableStep);
                if (mTrace)
                    context.Log(pret + "Flagged low obstacles as walkable.");

            }

            if ((mFlags & BuildFlags.LedgeSpansNotWalkable) != 0)
            {
                hf.MarkLedgeSpansNotWalkable(context
                    , mConfig.walkableHeight
                    , mConfig.walkableStep);
                if (mTrace)
                    context.Log(pret + "Flagged ledge spans as not walklable");
            }

            if ((mFlags & BuildFlags.LowHeightSpansNotWalkable) != 0)
            {
                hf.MarkLowHeightSpansNotWalkable(context
                    , mConfig.walkableHeight);
                if (mTrace)
                    context.Log(pret
                        + "Flagged low height spans as not walkable.");
            }

            if (mProcessors != null && mProcessors.HFCount > 0)
                mState = BuildState.HeightfieldPostProcess;
            else
                mState = BuildState.CompactFieldBuild;
        }

        private void PostProcessHeightfield()
        {
            Heightfield hf = (Heightfield)mPrimary;

            int count = mProcessors.HFCount;
            for (int i = 0; i < count; i++)
            {
                hf = mProcessors.GetHF(i).Process(context, hf);
            }

            mPrimary = hf;

            mState = BuildState.CompactFieldBuild;
        }

        private void BuildCompactField()
        {
            Heightfield hf = (Heightfield)mPrimary;

            CompactHeightfield chf = CompactHeightfield.Build(context
                , hf
                , mConfig.walkableHeight
                , mConfig.walkableStep);

            hf.RequestDisposal();
            mPrimary = null;

            if (chf == null)
            {
                context.Log(pre + "Aborted at compact heightfield build.");
                mState = BuildState.Aborted;
                return;
            }

            if (mTrace)
                context.Log(pret + "Built compact heightfield. Spans: " 
                    + chf.SpanCount);

            if (chf.SpanCount < 1)
            {
                context.Log("Aborted after compact heightfield build."
                    + " Heightfield does not have any spans.");
                mState = BuildState.Aborted;
                return;
            }

            mSecondary = chf;

            if (mProcessors != null && mProcessors.CHFCount > 0)
                mState = BuildState.CompactFieldMidProcess;
            else if (mConfig.walkableRadius > 0)
                mState = BuildState.ErodeWalkableArea;
            else
                mState = BuildState.DistanceFieldBuild;
        }

        private void MidProcessCompactField()
        {
            CompactHeightfield chf = (CompactHeightfield)mSecondary;

            int count = mProcessors.CHFCount;
            for (int i = 0; i < count; i++)
            {
                ICHFProcessor processor = mProcessors.GetCHF(i);
                if (!processor.IsPostProcessor)
                    chf = mProcessors.GetCHF(i).Process(context, chf);
            }

            mSecondary = chf;

            if (mConfig.walkableRadius > 0)
                mState = BuildState.ErodeWalkableArea;
            else
                mState = BuildState.DistanceFieldBuild;
        }

        private void ErodeWalkableArea()
        {
            CompactHeightfield chf = (CompactHeightfield)mSecondary;

            chf.ErodeWalkableArea(context, mConfig.walkableRadius);

            if (mTrace)
                context.Log(pret + "Eroded walkable area by radius.");

           mState = BuildState.DistanceFieldBuild;
        }

        private void BuildDistanceField()
        {
            CompactHeightfield chf = (CompactHeightfield)mSecondary;

            chf.BuildDistanceField(context);
            if (mTrace)
                context.Log(pret + "Built distance field. Max Distance: "
                    + chf.MaxDistance);

            mState = BuildState.RegionBuild;
        }

        private void BuildRegions()
        {
            CompactHeightfield chf = (CompactHeightfield)mSecondary;

            if ((mFlags & BuildFlags.UseMonotonePartitioning) != 0)
            {
                chf.BuildRegionsMonotone(context
                    , mConfig.borderSize
                    , mConfig.minRegionArea
                    , mConfig.mergeRegionArea);
                if (mTrace)
                    context.Log(pret + "Built monotone regions.");
            }
            else
            {
                chf.BuildRegions(context
                    , mConfig.borderSize
                    , mConfig.minRegionArea
                    , mConfig.mergeRegionArea);
                if (mTrace)
                    context.Log(pret + "Built regions. Region Count: "
                        + chf.MaxRegion);
            }

            if (chf.MaxRegion < 2)
            {
                // Null region counts as a region.  So expect
                // at least 2.
                context.Log("Completed after region build."
                    + " No useable regions formed.");
                mState = BuildState.Complete;
                mNoResult = true;
                return;
            }

            mState = BuildState.ContourBuild;
        }

        private void BuildContours()
        {
            ContourBuildFlags cflags =
                (ContourBuildFlags)((int)mFlags & 0x03);

            ContourSet cset = ContourSet.Build(context
                , (CompactHeightfield)mSecondary
                , mConfig.edgeMaxDeviation
                , mConfig.maxEdgeLength
                , cflags);

            if (cset == null)
            {
                context.Log(pre + "Aborted at contour set build.");
                mState = BuildState.Aborted;
                return;
            }

            if (mTrace)
                context.Log(pret + "Build contour set. Contour count: "
                    + cset.Count);

            if (cset.Count < 1)
            {
                context.Log("Aborted after contour build."
                    + " No contours were generated.");
                mState = BuildState.Aborted;
                return;
            }

            mPrimary = cset;

            mState = BuildState.PolyMeshBuild;
        }

        private void BuildPolyMesh()
        {
            ContourSet cset = (ContourSet)mPrimary;

            PolyMesh polyMesh = PolyMesh.Build(context
                , cset
                , mConfig.maxVertsPerPoly
                , mConfig.walkableHeight
                , mConfig.walkableRadius
                , mConfig.walkableStep);

            cset.RequestDisposal();

            if (polyMesh == null)
            {
                context.Log(pre + "Aborted at poly mesh build.");
                mState = BuildState.Aborted;
                return;
            }

            if (mTrace)
                context.Log(pret + "Built poly mesh. PolyCount: "
                    + polyMesh.PolyCount);

            if (polyMesh.PolyCount < 1)
            {
                context.Log(pre + "Aborted after poly mesh build."
                    + "No polygons were generated.");
                mState = BuildState.Aborted;
                return;
            }

            if ((mFlags & BuildFlags.ApplyPolyFlags) != 0)
            {
                PolyMeshData data = polyMesh.GetData(false);
                for (int i = 0; i < data.flags.Length; i++)
                {
                    data.flags[i] = NMGen.DefaultFlag;
                }

                polyMesh.Load(data);
                if (mTrace)
                    context.Log(pret 
                        + "Applied polymesh flag to all polys: 0x01");
            }
            mPrimary = polyMesh;

            if (mProcessors != null && mProcessors.PMCount > 0)
                mState = BuildState.PolyMeshPostProcess;
            else
                mState = BuildState.DetailMeshBuild;
        }

        private void PostProcessPolyMesh()
        {
            PolyMesh polyMesh = (PolyMesh)mPrimary;

            int count = mProcessors.PMCount;
            for (int i = 0; i < count; i++)
            {
                polyMesh = mProcessors.GetPM(i).Process(context, polyMesh);
            }

            mPrimary = polyMesh;
            mState = BuildState.DetailMeshBuild;
        }

        private void BuildDetailMesh()
        {
            PolyMesh polyMesh = (PolyMesh)mPrimary;
            CompactHeightfield chf = (CompactHeightfield)mSecondary;

            PolyMeshDetail detailMesh = PolyMeshDetail.Build(context
                , polyMesh
                , chf
                , mConfig.detailSampleDistance
                , mConfig.detailMaxDeviation);

            chf.RequestDisposal();

            if (detailMesh == null)
            {
                context.Log(pre + "Aborted at detail mesh build.");
                polyMesh.RequestDisposal();
                mPrimary = null;
                mSecondary = null;
                mState = BuildState.Aborted;
                return;
            }

            mSecondary = detailMesh;

            if (mTrace)
                context.Log(pret + "Built detail mesh. TriangleCount: "
                    + detailMesh.TriCount);

            if (detailMesh.MeshCount < 1)
            {
                context.Log(pre + "Aborted after detail mesh build."
                    + "No detail meshes generated.");
                polyMesh.RequestDisposal();
                detailMesh.RequestDisposal();
                mPrimary = null;
                mSecondary = null;
                mState = BuildState.Aborted;
                return;
            }

            if (mProcessors != null && mProcessors.DMCount > 0)
                mState = BuildState.DetailMeshPostProcess;
            else
                mState = BuildState.Complete;
        }

        private void PostProcessDetailMesh()
        {
            PolyMeshDetail detailMesh = (PolyMeshDetail)mSecondary;

            int count = mProcessors.DMCount;
            for (int i = 0; i < count; i++)
            {
                detailMesh = mProcessors.GetDM(i).Process(context, detailMesh);
            }

            mSecondary = detailMesh;

            mState = BuildState.Complete;
        }

        public static IncrementalBuilder Create(NMGenParams config
            , BuildFlags buildFlags
            , NMGenInputGeom mesh
            , ProcessorSet processors
            , bool trace)
        {
            if (config == null
                || mesh == null
                || processors == null)
            {
                return null;
            }

            Vector3 bmin;
            Vector3 bmax;

            Vector3Util.GetBounds(mesh.UnsafeVerts, mesh.UnsafeVerts.Length
                , out bmin, out bmax);

            NMGenTileParams tileConfig = new NMGenTileParams(0, 0, bmin, bmax);

            return new IncrementalBuilder(tileConfig
                , config, buildFlags, mesh, processors, trace);
        }

        public static IncrementalBuilder Create(int tx, int tz
            , TileSetDefinition tileDef
            , ProcessorSet processors
            , bool trace)
        {
            if (tileDef == null || processors == null)
                return null;
            if (tx < 0 || tz < 0 || tx >= tileDef.Width || tz >= tileDef.Depth)
                return null;

            NMGenTileParams tileConfig;
            NMGenInputGeom geom;

            if (!tileDef.GetInputGeometry(tx, tz, out tileConfig, out geom))
                return null;

            if (geom == null)
            {
                // This is NOT a failure.  There simply isn't any geometry
                // in the bounds of the tile.
                // The default constructor creates a "no result" builder.
                return new IncrementalBuilder();
            }

            return new IncrementalBuilder(tileConfig
                , tileDef.GetBaseConfig()
                , tileDef.BuildFlags
                , geom
                , processors
                , trace);
        }

        /// <summary>
        /// Returns human friendly text for the specified state.
        /// </summary>
        /// <param name="state">The state.</param>
        /// <returns>Human friendly text.</returns>
        public static string ToLabel(BuildState state)
        {
            switch (state)
            {
                //case BuildState.Inactive:
                //    return "Inactive";
                case BuildState.Aborted:
                    return "Aborted.";
                case BuildState.CompactFieldBuild:
                    return "Building compact heightfield.";
                case BuildState.CompactFieldMidProcess:
                    return "Post processing compact heightfield.";
                case BuildState.Complete:
                    return "Complete";
                case BuildState.ContourBuild:
                    return "Building contours.";
                case BuildState.DetailMeshBuild:
                    return "Building detail mesh.";
                case BuildState.DetailMeshPostProcess:
                    return "Post processing detail mesh.";
                case BuildState.DistanceFieldBuild:
                    return "Building distance field.";
                case BuildState.ErodeWalkableArea:
                    return "Eroding walkable area.";
                case BuildState.HeightfieldBuild:
                    return "Building heightfield.";
                case BuildState.HeightfieldPostProcess:
                    return "Post processing heightfield.";
                case BuildState.MarkHeightfieldSpans:
                    return "Marking heightfield spans.";
                case BuildState.ClearUnwalkableTris:
                    return "Clearing unwalkable triangles.";
                case BuildState.PolyMeshBuild:
                    return "Building polygon mesh.";
                case BuildState.PolyMeshPostProcess:
                    return "Post processing polygon mesh.";
                case BuildState.RegionBuild:
                    return "Building regions.";
            }
            return "Error";
        }

        /// <summary>
        /// Returns a progress value associated with the specified state. 
        /// </summary>
        /// <remarks>
        /// The value will be between 0 and 1.0 and is suitable for providing
        /// build progress feedback.
        /// </remarks>
        /// <param name="state">The state.</param>
        /// <returns>A progress value for teh state.</returns>
        public static float ToProgress(BuildState state)
        {
            switch (state)
            {
                //case BuildState.Inactive:
                //    return 0;
                case BuildState.Initialized:
                    return 0;
                case BuildState.ClearUnwalkableTris:
                    return 0.04f;
                case BuildState.HeightfieldBuild:
                    return 0.08f;
                case BuildState.MarkHeightfieldSpans:
                    return 0.25f;
                case BuildState.HeightfieldPostProcess:
                    return 0.30f;
                case BuildState.CompactFieldBuild:
                    return 0.35f;
                case BuildState.CompactFieldMidProcess:
                    return 0.45f;
                case BuildState.ErodeWalkableArea:
                    return 0.40f;
                case BuildState.DistanceFieldBuild:
                    return 0.55f;
                case BuildState.RegionBuild:
                    return 0.60f;
                case BuildState.ContourBuild:
                    return 0.70f;
                case BuildState.PolyMeshBuild:
                    return 0.75f;
                case BuildState.PolyMeshPostProcess:
                    return 0.80f;
                case BuildState.DetailMeshBuild:
                    return 0.85f;
                case BuildState.DetailMeshPostProcess:
                    return 0.95f;
                case BuildState.Complete:
                    return 1;
                case BuildState.Aborted:
                    return 1;
            }
            return 1;
        }

    }
}
