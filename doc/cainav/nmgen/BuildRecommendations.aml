<?xml version="1.0" encoding="utf-8"?>
<topic id="d6a98454-7e5d-4e85-9e9d-29d4c517f6a6" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
    
      <para>The NMGen build process is meant to work for a wide variety of source geometry types and navigation mesh needs.
			This topic covers various common tips and recommendations that will help you get started.</para>
      
      <para>This information will help you understand what the primary configuration parameters do, some good
      starting values, and the side effects parameters have on each other.</para>
      
			
      This means that it needs to support a wide variety of configuration settings. There is no 
      "one size fits all" configuration. Instead, you will usually discover configurations that work well 
      for categories of source geometry. E.g. A configuration for interior environments and another for 
      outdoor environments.
			
      <alert class="note">
      
        <para>You will need to understand 
        <link xlink:href="6fb3041b-e9be-4f03-868b-dcac944df19b">heightfields</link> and the 
        <link xlink:href="e72bd1ee-04b0-4bbb-a21d-d8d7ecaa11af">build process</link> before you can properly
        understand the information presented here.</para>
        
        <para>While not technically accurate, in the context of this document the term "navigation mesh" 
        refers to the <token>PolyMesh</token> and <token>DetailMesh</token> data generated by a NMGen build.</para>
        
        <para>See <codeEntityReference>T:org.critterai.nmgen.NMGenParams</codeEntityReference> 
        for a full list of parameters.
        </para>
        
      </alert>
      
    </introduction>
 
 	<section address="mistakes">
 	
      <title>Common Mistakes</title>
 	
      <content>
      
        <para>The primary concern of most path planners is accurate movement on the xz-plane. 
        The y-axis (height) usually only comes into play in cases where traversable areas overlap 
        or cost of movement is effected by the slope of the geometry. Also, due to performance and 
        memory concerns, path planners need a navigation mesh with the lowest possible number of polygons 
        that will still get the job done. Placing the client at the proper point on the surface of the
        source geometry is usually the job of physics and/or locomotion, not the path planner.</para>
        
        <para>A common mistake is to try to build a navigation mesh that too accurately follows the edges 
        and height contour of the source geometry, resulting in a mesh with a high polygon count that
        results in performance and memory issues for the path planner.</para>
        
      </content>
 	
 	</section>
 
    <section address="clientParams">
    
      <title>Client Based Configuration Parameters</title>
      
      <content>
        <para>The settings in this section are usually based on the intended client of the navigation mesh 
        rather than the source geometry. The client may be a robot, a human-type agent, a dinosaur, a truck, etc. 
        The area of the source geometry that is considered traversable is dictated by the type of clients that 
        will use the navigation mesh.</para>
      </content>
      
      <sections>
      
        <section address="xzCellSize">
          
          <title>XZCellSize</title>
              
          <content>
              
              <para>Effects how accurately the final navigation mesh can conform to the source geometry on the xz-plane. 
              E.g. How close it can follow follow the edges of obstructions.  It has side effects on
              most parameters that apply to the xz-plane. <link xlink:href="#walkableRadius">WalkableRadius</link>
              for example.</para>
              
              <para>The primary governing factor for choosing the XZCellSize is the value of the client radius.
              Start with <codeInline>maxClientRadius/2</codeInline> for outdoor environments.  For indoor environments or
              when more accuracy is needed, start with <codeInline>maxClientRadius/3</codeInline>.</para>
              
              <para>There are special considerations when the source geometry covers a large area.  The best
              solution is use multiple polygon meshes configured to be used with a tiled 
              <codeEntityReference>T:org.critterai.nav.Navmesh</codeEntityReference>.  Otherwise you may need to accept lower resolution,
              and base the XZCellSize on the source geometry's longest xz-axis.  In this case, start with a value of 
              <codeInline>longestAxis/1000</codeInline>, then reduce the size as performance and memory allows.</para>
                  
          </content>
          
        </section>
          
        <section address="yCellSize">
          
          <title>YCellSize</title>
              
          <content>
              
              <para>Effects how accurately the height of the final navigation mesh can conform to 
              the source geometry. It has side effects on most parameters that apply to the y-axis.  
              <link xlink:href="#walkableHeight">WalkableHeight</link> and
              <link xlink:href="#walkableStep">WalkableStep</link>
              for example.</para>
              
              <para>This parameter is based primarily on how far up/down the client can step.
              Start with <codeInline>maxClientStep/2.5</codeInline> and decrease the value as needed.</para>
              
              <para>Smaller values can result in a moderate increase in build times.  But the effect on 
              memory is minimal.</para>

          </content>
          
        </section>
          
        <section address="walkableHeight">
          
          <title>WalkableHeight</title>
              
          <content>
              
		    <para>Determines where a client can walk based on 'floor' to 'ceiling' height.  Only areas 
		    of the source geometry that meet this height requirement will have mesh coverage.
            Start with <codeInline>ceil(maxClientHeight/yCellSize)</codeInline>.</para>
		    
            <para>Example: Consider a table setting on a floor. With this parameter set correctly, the floor 
            area under the table will not be considered walkable.</para>
             
           <mediaLink><image xlink:href="Value-WalkableHeight"/></mediaLink>

          </content>
          
        </section>
          
        <section address="walkableStep">
          
          <title>WalkableStep</title>
              
          <content>
              
		    <para>Determines when a ledge in the source geometry can be traversed, rather than 
		    acting as an obstruction.</para>
		    
		    <para>This parameter is normally based on how far up/down the client can step.  
		    Though often it needs to be set higher because of the way the source geometry is designed. 
		    Start with <codeInline>ceil(maxClientStep/yCellSize)</codeInline> and adjust from there.</para>
		    
            <mediaLink><image xlink:href="Value-WaklableStep"/></mediaLink>

          </content>
          
        </section>
        
        <section address="walkableRadius">
          
          <title>WalkableRadius</title>
              
          <content>
              
		    <para>Effects size of the border around obstacles. Many path planners (including 
		    <application>CAINav</application>) see clients as a point on the navigation mesh. So the navigation mesh  
		    needs to be eroded by the client's radius so the planner won't plan a path that comes too close to obstructions, 
		    or passes through areas that are too thin for the client to fit. So start with
		    <codeInline>ceil(maxClientRadius/xzCellSize)</codeInline></para>
		    
		    <alert clas="note">
		      <para><application>CAINav</application> does not inherently support the use of a single
		      navigation mesh for clients with largely varying radii.  (E.g. A human and a truck.) 
		      In such cases you'll need either have multiple navigation meshes sized for each  
		      client type, or implement your own custom handling.</para>
		    </alert>
		    
            <mediaLink><image xlink:href="Value-WalkableRadius"/></mediaLink>

          </content>

        </section>
          
        <section address="walkableSlope">
          
          <title>WalkableSlope</title>

          <content>
            
		    <para>This parameter is used very early in the build process, filtering out all source triangles that have a slope
		    greater than its value.  The choice of the value is entirely dependant on the maximum slope the client's
		    locomotion can handle. A good value to start with is slightly over 45 degrees.</para>

          </content>

        </section>
        
      </sections>
      
    </section>
    
    <section address="geomParams">
    
      <title>Source Geometry Based Configuration Parameters</title>
      
      <content>
        <para>The parameters in this section are usually based on the structure of the source geometry and how closely the navigation 
        mesh must match the geometry.</para>
      </content>
      
      <sections>
      
        <section address="maxEdgeLength">
          
          <title>MaxEdgeLength</title>
              
          <content>
          
            <para>Sometimes the build process can result in long thin triangles along the mesh edges.
            Start with a maximum edge length of zero (disabled).  If you see a problem, then
            start with <codeInline><link xlink:href="#walkableRadius">walkableRadius</link> * 8</codeInline> 
            and adjust from there.</para>
          
          	<alert class="note">
          	<para>Despite the similar names, MaxEdgeLength and 
          	<link xlink:href="#edgeMaxDeviation">EdgeMaxDeviation</link> do not have significant side 
          	effects on each other.</para>
          	</alert>
          
          </content>
          
        </section>
        
        <section address="edgeMaxDeviation">
          
          <title>EdgeMaxDeviation</title>
              
          <content>
          
            <para>The 
            <externalLink>
			  <linkText>Douglas–Peucker algorithm</linkText>
			  <linkUri>http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm</linkUri>
			  <linkTarget>_blank</linkTarget>
			</externalLink>
			is used when simplifying the borders of the navigation mesh.  This parameter effects how much 
			simplification occurs.  A higher number will result in more lost detail, but also fewer
			unnecessary polygons around the border. A good place to start is between 1.1 and 1.5.  
			Low values, especially zero (no simplification), are not recommended since it can result in a 
			large number of small triangles around the border.
			</para>

          </content>
          
        </section>
        
        <section address="detailSampling">
          
          <title>DetailSampleDistance and DetailMaxDeviation</title>
              
          <content>
          
            <para>These two parameters only effect the creation of the <token>DetailMesh</token>.</para>
			
			<para>The sample distance is used to create sample points on the polygon edges and across the surface 
			of the <token>PolyMesh</token>.  The height distance from the polygon edge/surface is tested. If the maximum deviation 
			is exceeded, then the sample point is added to the detail mesh.</para>
			
			<para>These parameters should be set as high as possible while still getting the desired height detail. Setting the sample 
			distance to less than 0.9 will effectively disable this functionality.  Setting the maximum deviation is zero is not recommended
			since it will result is a large number of detail triangles.</para>
			
			<para>Start with a sample distance of <codeInline>longestXZAxis / 100</codeInline>, where 
			<codeInline>longestXZAxis</codeInline> is based on the bounds of the source geometry, and a 
			maximum deviation of <codeInline>yCellSize * 20</codeInline></para>

          </content>
          
        </section>
        
        <section address="minRegionArea">
          
          <title>MinRegionArea</title>
              
          <content>
          
            <para>Defines the minimum area allowed for isolated meshes that are too small to be of use. 
            (Island regions.)</para>
            
            <alert class="note">
              <para>The display name for this in the Unity Editor is "Min Island Area".</para>
            </alert>
            
            <para>If you really don't want or expect any island regions, then set this parameter to a high value.
            Otherwise the value will depend entirely on your needs.</para>
            
            <para>In the example below, the island area has been set too low, allowing the formation of small meshes on the top of obstructions.
            </para>
            
            <mediaLink><image xlink:href="Value-MinRegionArea"/></mediaLink>

          </content>
          
        </section>
        
      </sections>
      
    </section>
    
    <relatedTopics>
    
			<codeEntityReference>T:org.critterai.nmgen.NMGenParams</codeEntityReference>
			<codeEntityReference>M:org.critterai.nmgen.NMGen.BuildPolyMesh(org.critterai.nmgen.NMGenParams,org.critterai.nmgen.BuildFlags,org.critterai.geom.TriangleMesh,org.critterai.nmgen.PolyMesh@,org.critterai.nmgen.PolyMeshDetail@,System.String[]@,System.Boolean)</codeEntityReference>
			<codeEntityReference>T:org.critterai.nmbuild.IncrementalBuilder</codeEntityReference>
			<codeEntityReference>T:org.critterai.nmgen.u3d.NMGenBuildParams</codeEntityReference>
			<codeEntityReference>T:NMGenBuildConfig</codeEntityReference> <!-- In root namespace. -->
			
			<link xlink:href="0b06b934-9f2b-43a3-a96b-6fd9dc8483c7"/> <!-- NMGenIntro -->
			<link xlink:href="6fb3041b-e9be-4f03-868b-dcac944df19b"/> <!-- HeightfieldIntro -->
			<link xlink:href="e72bd1ee-04b0-4bbb-a21d-d8d7ecaa11af"/> <!-- NMGenBuildProcess -->
			<link xlink:href="d6a98454-7e5d-4e85-9e9d-29d4c517f6a6"/> <!-- NMGenBuildRecommendations -->

    </relatedTopics>
    
  </developerConceptualDocument>
</topic>