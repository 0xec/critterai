<?xml version="1.0" encoding="utf-8"?>
<topic id="8a99e478-a235-49ef-986d-db53a0bc50bb" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">

    <introduction>
     
      <para>The first thing to understand about <application>CAINav</application> is that it is 
      not a plug-and-play solution. Well, NMGen is kind of plug-and-play. But creating the navigation 
      mesh is just the starting point. To use the navigation mesh you'll need to implement your own 
      code. And to do that you'll need to understand <application>CAINav's</application> structure.</para>
      
      <alert class="note">
      
	      <para>Some Definitions</para>
	      
	      <para>Navigation Mesh Data: Structural and other data required to create a navigation mesh. 
	      (The "mesh" is only part of the puzzle.)</para>
	      
	      <para>Core Classes: Classes that provide the core functionality. They are part of the .NET API, 
	      so they are available for use by all coders/scripters.</para>
	      
	      <para>Unity Extensions: Classes that provide optional utility functionality for 
	      <token>Unity</token> scripters.</para>
	      
	      <para>Unity Components: Optional Unity Editor components. They make life easier, but support a 
	      limited subset of functionality.</para>
      
      </alert>
      
    </introduction>
   
    <section address="10KView">
    
      <title>The 10,000 Meter View</title>
      
      <content>
      
        <para>The below diagram describes the relationships of the core components from a construction 
        perspective. The dividing line between NMGen and the navigation components is a structural one. 
        There are no library dependencies between the two. So with a little bit of bridge code you can 
        completely separate the generation of navigation mesh data from the use of the data for 
        navigation.</para>
        
        <mediaLink>
          <image xlink:href="CaiNavComponents"/>
        </mediaLink>
        
      </content>
      
    </section>
    
    <section address="SourceGeometry">
    
      <title>1 - Source Geometry</title>
      
      <content>
      
        <para>In order to generate the core navigation mesh data you have to have some sort of source 
        geometry from which you can obtain vertex and triangle data. In Unity, the source geometry is
        usually obtained from MeshFilters. But anything that provides vertices and indices can be used.</para>
        
        <para>Core Class: 
        <codeEntityReference>T:org.critterai.geom.TriangleMesh</codeEntityReference>
        </para>
        
        <para>Unity Components:
        <codeEntityReference qualifyHint="false">T:DSGeometry</codeEntityReference>,
        <codeEntityReference qualifyHint="false">T:MeshFilterSource</codeEntityReference>,
        <codeEntityReference qualifyHint="false">T:TaggedMeshFilterSource</codeEntityReference>
        </para>
        
        <alert class="tip">
          <para>If you want to create your own geometry data source in Unity, all you need to do is
          extend the <codeEntityReference qualifyHint="false">T:DSGeometry</codeEntityReference> 
          class.</para>
        </alert>
        
        <para>Triangle wrap direction on the xz-plane is used for the detection of which face of the triangle is 
        considered up. (The y-axis is up/down.) A picture is worth a thousand words. If your source geometry is wrapped differently 
        than shown, then it will need to be translated into this format before use in the NMGen 
        build pipeline.</para>
        
        <mediaLink>
          <image xlink:href="WrapDirection"/>
        </mediaLink>
        
      </content>
      
    </section>
    
    <section address="NMGenBuildConfig">
    
      <title>2 - NMGen Build Configuration</title>
      
      <content>
      
        <para>Source geometry may represent exterior natural geography or interior environments in any number 
        of different styles. The navigation clients may be human-type agents, large vehicles, 
        wheeled robots, etc.; each with its own locomotion restrictions. For these reasons NMGen supports a large variety of 
        configuration settings that adjust how the navigation mesh data is generated.</para>
        
		<para>Core Class: 
		<codeEntityReference>T:org.critterai.nmgen.NMGenParams</codeEntityReference>
		</para>
		
		<para>Unity Extension: 
		<codeEntityReference>T:org.critterai.nmgen.u3d.NMGenBuildParams</codeEntityReference>
		</para>
		
		<para>Unity Component: 
		<codeEntityReference qualifyHint="false">T:NMGenBuildConfig</codeEntityReference>
		</para>
        
      </content>
      
    </section>
    
    <section address="PolyMeshes">
    
      <title>3 - Polygon and Detail Meshes</title>
      
      <content>
      
        <para>The source geometry and build configuration are used to create two types of meshes. The 
        polygon mesh provides the data needed for pathfinding operations. The detail mesh provides extra 
        height detail that is lacking in the polygon mesh. Together, these meshes provide the core structural
        data for the navigation mesh.</para>
        
		<para>Core Classes: 
		<codeEntityReference>T:org.critterai.nmgen.PolyMesh</codeEntityReference>,
		<codeEntityReference>T:org.critterai.nmgen.PolyMeshDetail</codeEntityReference>
		</para>
		
		<para>Unity Component: 
		<codeEntityReference qualifyHint="false">T:BakedPolyMesh</codeEntityReference>
		</para>
		  
        <mediaLink>
          <image xlink:href="PolyMesh-Basic"/>
        </mediaLink>
        
        <mediaLink>
          <image xlink:href="PolyMeshDetail-Basic"/>
        </mediaLink>
        
      </content>
      
    </section>
    
    <section address="NavmeshTiles">
    
      <title>4 - Navigation Mesh Tiles </title>
      
      <content>
      
        <para>Tiles contain the data that makes up the navigation mesh. A navigation mesh 
        cannot exist without at least one tile. But there can be more. The ability to have multiple 
        tiles in a navigation mesh opens up a huge variety of options. Think: Navigation meshes that 
        cover large or complex areas, swapping tiles in and out at runtime, etc.</para>
        
        <para>As a minimum, each tile contains a polygon mesh.  It can also contain optional data such as
        a detail mesh and off-mesh connections.</para>
        
        <para>There are multiple ways to building and adding tiles to a navigation mesh. Some easier, 
        some not so easy. That is why there are multiple core classes.</para>
        
        <para>Core Classes:
        <codeEntityReference>T:org.critterai.nav.NavmeshTileBuildData</codeEntityReference>,
        <codeEntityReference>T:org.critterai.nav.NavmeshTileData</codeEntityReference>,
        <codeEntityReference>T:org.critterai.nav.NavmeshTile</codeEntityReference>
        </para>
        
      </content>
      
    </section>
    
    <section address="Navmesh">
    
      <title>5 - Navigation Mesh</title>
      
      <content>
      
        <para>A navigation mesh may contain a single rectangle tile, or a grid of square tiles. It is compact 
        and efficient with various ways of serializing, de-serializing, and swapping data in and out at 
        runtime.</para>
        
		<para>Core Class: 
		<codeEntityReference>T:org.critterai.nav.Navmesh</codeEntityReference>
		</para>
		
		<para>Unity Component: 
		<codeEntityReference qualifyHint="false">T:BakedNavmesh</codeEntityReference>
		</para>
        
        <alert class="note">
        <para>The Unity component doesn't currently support advanced features such as multi-tile meshes and 
        off-mesh connections. You'll need to implement your own solutions if you want to use those features.
        </para>
        </alert>
        
      </content>
      
    </section>
    
    <section address="NavmeshQuery">
    
      <title>6 - Navigation Mesh Query</title>
      
      <content>
      
        <para>The navigation mesh query is what all clients use to perform pathfinding and related 
        queries against the navigation mesh. Even if you use the crowd manager for steering, you'll 
        need to use a navigation mesh query for non-local pathfinding and other higher level planning.</para>
        
		<para>Core Class: 
		<codeEntityReference>T:org.critterai.nav.NavmeshQuery</codeEntityReference>
		</para>
		
		<para>Unity Extension: 
		<codeEntityReference>T:org.critterai.nav.u3d.U3DNavmeshQuery</codeEntityReference>
		</para>
		
		<para>Unity Component: 
		<codeEntityReference qualifyHint="false">T:NavSource</codeEntityReference>
		</para>
       
        <mediaLink>
          <image xlink:href="Explorer-StraightPath"/>
        </mediaLink>
        
      </content>
      
    </section>
    
    <section address="NavmeshQueryFilter">
    
      <title>7 - Query Filter</title>
      
      <content>
      
        <para>Filters allow pathfinding behavior to be altered at runtime without changing the structure of 
        the navigation mesh. They are used in most query methods to indicate which navigation mesh polygons 
        are considered accessible and which aren't. They also define the traversal cost of different types 
        of polygons.</para>
        
        <para>Filters can be specific to individual agents or shared between groups of agents.</para>
        
		<para>Core Class: 
		<codeEntityReference>T:org.critterai.nav.NavmeshQueryFilter</codeEntityReference>
		</para>
        
      </content>
      
    </section>
    
    <section address="CrowdManager">
    
      <title>8 - Crowd Manger</title>
      
      <content>
      
        <para>The crowd manager implements local steering. You provide it with agent's 
        to manage and local targets for the agents to move to, and it handles steering the agents in 
        order to avoid collisions with other agents.</para>
        
        <alert class="important">
        <para>The use of the term "local" is important. CrowdManager can't do long distance path planning.
        </para>
        </alert>
        
		<para>Core Class: 
		<codeEntityReference>T:org.critterai.nav.CrowdManager</codeEntityReference>
		</para>
		
		<para>Unity Component: 
		<codeEntityReference qualifyHint="false">T:NavSource</codeEntityReference>
		</para>
        
      </content>
      
    </section>
    
    <section address="dependencies">
    
      <title>Dependencies and Layers</title>
      
      <content>
      
        <para><application>CAINav</application> consists of multiple libraries, some optional.</para>

        <alert class="note">
          <para>Duplicate dependencies are not show.</para>
        </alert>

        <mediaLink>
          <image xlink:href="CAINavDependencies"/>
        </mediaLink>
        
        <para>The native plug-ins and .NET API libraries are required. The rest are optional.</para>
        
        <para>The Unity package includes optional bridge scripts, not show in the diagram, that are dependent 
        on both the NMGen and navigation libraries.</para>
        
      </content>
      
    </section>
    
  </developerConceptualDocument>
</topic>